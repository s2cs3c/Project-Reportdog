var mongoose = require('mongoose');
var Schema = mongoose.Schema;

var customField = {
    _id:            false,
    customField:  {type: Schema.Types.ObjectId, ref: 'CustomField'},
    text:           Schema.Types.Mixed
}

var VulnerabilityDetails = {
    _id:            false,
    locale:         String,
    // language:       String,
    title:          {type: String, unique: true, sparse: true},
    vulnType:       String,
    description:    String,
    observation:    String,
    remediation:    String,
    references:     [String],
    customFields:   [customField]
}

var VulnerabilitySchema = new Schema({
    cvssv3:                 String,
    cvssv4:                 String,
    priority:               {type: Number, enum: [1,2,3,4]},
    remediationComplexity:  {type: Number, enum: [1,2,3]},
    details:                [VulnerabilityDetails],
    status:                 {type: Number, enum: [0,1,2], default: 1}, // 0: validated, 1: created, 2: updated,
    category:               String,
    creator:                {type: Schema.Types.ObjectId, ref: 'User'}


}, {timestamps: true});

/*
*** Statics ***
*/

// Get all vulnerabilities with visibility filter
// isAdmin: if true, returns all vulnerabilities
// userId: if not admin, only returns status=0, status=2, or status=1 where creator matches userId
VulnerabilitySchema.statics.getAll = (isAdmin = true, userId = null) => {
    return new Promise((resolve, reject) => {
        var filter = {};
        
        // If not admin, apply visibility filter
        if (!isAdmin) {
            if (userId) {
                // Non-admin with userId: show validated, updates, and own unapproved
                filter = {
                    $or: [
                        { status: 0 }, // Validated - visible to all
                        { status: 2 }, // Updates - visible to all
                        { status: 1, creator: userId } // New/unapproved - only visible to creator
                    ]
                };
            } else {
                // Non-admin without userId: most restrictive filter (no unapproved)
                filter = {
                    $or: [
                        { status: 0 }, // Validated - visible to all
                        { status: 2 }  // Updates - visible to all
                    ]
                };
            }
        }
        
        var query = Vulnerability.find(filter);
        query.populate('creator', '-_id username');
        query.exec()
        .then((rows) => {
            resolve(rows);
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Get all vulnerabilities for download
VulnerabilitySchema.statics.export = () => {
    return new Promise((resolve, reject) => {
        var query = Vulnerability.find();
        query.select('details cvssv3 cvssv4 priority remediationComplexity references category -_id')
        query.exec()
        .then((rows) => {
            resolve(rows);
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Create vulnerability
VulnerabilitySchema.statics.create = (vulnerabilities) => {
    return new Promise((resolve, reject) => {
        Vulnerability.insertMany(vulnerabilities, {ordered: false})
        .then((rows) => {
            resolve({created: rows.length, duplicates: 0});
        })
        .catch((err) => {
            if (err.code === 11000) {
                if (err.result.insertedCount === 0)
                    reject({fn: 'BadParameters', message: 'Vulnerability title already exists'});
                else {
                    var errorMessages = [] 
                    err.writeErrors.forEach(e => errorMessages.push(e.errmsg || "no errmsg"))
                    resolve({created: err.result.insertedCount, duplicates: errorMessages});
                }
            }
            else
                reject(err);
        })
    })
}

// Update vulnerability
VulnerabilitySchema.statics.update = (vulnerabilityId, vulnerability) => {
    return new Promise((resolve, reject) => {
        var VulnerabilityUpdate = mongoose.model("VulnerabilityUpdate");
        var query = Vulnerability.findByIdAndUpdate(vulnerabilityId, vulnerability);
        query.exec()
        .then((row) => {
            if (!row)
                reject({fn: 'NotFound', message: 'Vulnerability not found'});
            else {
                var query = VulnerabilityUpdate.deleteMany({vulnerability: vulnerabilityId});
                return query.exec();
            }
        })
        .then((row) => {
            resolve('Vulnerability updated successfully');    
        })
        .catch((err) => {
            if (err.code === 11000)
                reject({fn: 'BadParameters', message: 'Vulnerability title already exists'});
            else
                reject(err);
        })
    });
}

// Delete all vulnerabilities
VulnerabilitySchema.statics.deleteAll = () => {
    return new Promise((resolve, reject) => {
        var query = Vulnerability.deleteMany();
        query.exec()
        .then(() => {
            resolve('All vulnerabilities deleted successfully');
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Delete vulnerability
VulnerabilitySchema.statics.delete = (vulnerabilityId) => {
    return new Promise((resolve, reject) => {
        var query = Vulnerability.findByIdAndDelete(vulnerabilityId);
        query.exec()
        .then((rows) => {
            if (rows)
                resolve(rows);
            else
                reject({fn: 'NotFound', message: 'Vulnerability not found'});
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Bulk approve vulnerabilities (set status to 0 = validated)
// Also deletes any associated VulnerabilityUpdates
VulnerabilitySchema.statics.bulkApprove = (vulnerabilityIds) => {
    return new Promise(async (resolve, reject) => {
        try {
            if (!vulnerabilityIds || vulnerabilityIds.length === 0) {
                reject({fn: 'BadParameters', message: 'No vulnerability IDs provided'});
                return;
            }

            var VulnerabilityUpdate = mongoose.model("VulnerabilityUpdate");
            
            // Update all vulnerabilities to status 0 (validated)
            const updateResult = await Vulnerability.updateMany(
                { _id: { $in: vulnerabilityIds } },
                { $set: { status: 0 } }
            );

            // Delete all associated VulnerabilityUpdates
            await VulnerabilityUpdate.deleteMany({ vulnerability: { $in: vulnerabilityIds } });

            resolve({
                approved: updateResult.modifiedCount,
                total: vulnerabilityIds.length
            });
        } catch (err) {
            reject(err);
        }
    });
}

// Get vulnerabilities by language with visibility filter
VulnerabilitySchema.statics.getAllByLanguage = (locale, isAdmin = true, userId = null) => {
    return new Promise((resolve, reject) => {
        var filter = {'details.locale': locale};
        
        // If not admin, apply visibility filter
        if (!isAdmin) {
            if (userId) {
                // Non-admin with userId: show validated, updates, and own unapproved
                filter = {
                    'details.locale': locale,
                    $or: [
                        { status: 0 }, // Validated - visible to all
                        { status: 2 }, // Updates - visible to all
                        { status: 1, creator: userId } // New/unapproved - only visible to creator
                    ]
                };
            } else {
                // Non-admin without userId: most restrictive filter (no unapproved)
                filter = {
                    'details.locale': locale,
                    $or: [
                        { status: 0 }, // Validated - visible to all
                        { status: 2 }  // Updates - visible to all
                    ]
                };
            }
        }
        
        var query = Vulnerability.find(filter)
        query.select('details cvssv3 cvssv4 priority remediationComplexity category')
        query.exec()
        .then((rows) => {
            if (rows) {
                var result = [];
                rows.forEach(row => {
                    row.details.forEach(detail => {
                        if (detail.locale === locale && detail.title){
                            var temp = {};
                            temp.cvssv3 = row.cvssv3;
                            temp.cvssv4 = row.cvssv4;
                            temp.priority = row.priority;
                            temp.remediationComplexity = row.remediationComplexity;
                            temp.category = row.category;
                            temp.detail= detail;
                            temp._id = row._id;
                            result.push(temp);
                        }
                    })
                })
                resolve(result);
            }
            else
                reject({fn: 'NotFound', message: 'Locale with existing title not found'});
        })
        .catch((err) => {
            reject(err);
        })
    });
}

// Merge multiple vulnerabilities into a new one
// vulnIds: array of vulnerability IDs to merge
// title: title for the merged vulnerability (default: "Merged Findings")
// locale: locale for the merged vulnerability
VulnerabilitySchema.statics.Merge = (vulnIds, title = "Merged Findings", locale = "en") => {
    return new Promise(async (resolve, reject) => {
        try {
            if (!vulnIds || vulnIds.length < 2) {
                reject({fn: 'BadParameters', message: 'At least 2 vulnerability IDs are required'});
                return;
            }

            // Fetch all vulnerabilities to merge
            const vulnerabilities = await Vulnerability.find({ _id: { $in: vulnIds } });
            
            if (vulnerabilities.length < 2) {
                reject({fn: 'NotFound', message: 'Not enough vulnerabilities found'});
                return;
            }

            // Build merged description with all titles and descriptions
            let mergedDescription = '';
            let mergedObservation = '';
            let mergedRemediation = '';
            let allReferences = [];
            
            // Find highest values for CVSS, priority, remediationComplexity
            let highestCvssv3 = null;
            let highestCvssv3Score = 0;
            let highestCvssv4 = null;
            let highestCvssv4Score = 0;
            let highestPriority = null;
            let highestRemediationComplexity = null;
            let category = null;

            // Helper function to extract CVSS score from vector string
            const getCvssScore = (cvssVector, version) => {
                if (!cvssVector) return 0;
                try {
                    // Try to extract score from common patterns
                    // CVSS:3.x/AV:... format doesn't include score, so we just compare by severity metrics
                    // For simplicity, we'll count high-severity metrics
                    const highSeverityMetrics = ['AV:N', 'AC:L', 'PR:N', 'UI:N', 'S:C', 'C:H', 'I:H', 'A:H'];
                    let score = 0;
                    highSeverityMetrics.forEach(metric => {
                        if (cvssVector.includes(metric)) score++;
                    });
                    return score;
                } catch (e) {
                    return 0;
                }
            };

            vulnerabilities.forEach((vuln, index) => {
                // Process each detail (language) in the vulnerability
                vuln.details.forEach(detail => {
                    if (detail.title) {
                        // Add title and description to merged content
                        mergedDescription += `<h3>== Original Finding: ${detail.title} ==</h3>\n`;
                        if (detail.description) {
                            mergedDescription += detail.description + '\n\n';
                        }
                        
                        // Collect observations
                        if (detail.observation) {
                            mergedObservation += `<h4>${detail.title}</h4>\n`;
                            mergedObservation += detail.observation + '\n\n';
                        }
                        
                        // Collect remediations
                        if (detail.remediation) {
                            mergedRemediation += `<h4>${detail.title}</h4>\n`;
                            mergedRemediation += detail.remediation + '\n\n';
                        }
                        
                        // Collect references
                        if (detail.references && detail.references.length > 0) {
                            allReferences = allReferences.concat(detail.references);
                        }
                    }
                });

                // Compare and keep highest CVSS scores
                const cvssv3Score = getCvssScore(vuln.cvssv3, 3);
                if (cvssv3Score > highestCvssv3Score) {
                    highestCvssv3Score = cvssv3Score;
                    highestCvssv3 = vuln.cvssv3;
                }

                const cvssv4Score = getCvssScore(vuln.cvssv4, 4);
                if (cvssv4Score > highestCvssv4Score) {
                    highestCvssv4Score = cvssv4Score;
                    highestCvssv4 = vuln.cvssv4;
                }

                // Keep highest priority (4 is urgent, highest)
                if (vuln.priority && (!highestPriority || vuln.priority > highestPriority)) {
                    highestPriority = vuln.priority;
                }

                // Keep highest remediation complexity (3 is complex, highest)
                if (vuln.remediationComplexity && (!highestRemediationComplexity || vuln.remediationComplexity > highestRemediationComplexity)) {
                    highestRemediationComplexity = vuln.remediationComplexity;
                }

                // Use first non-null category
                if (!category && vuln.category) {
                    category = vuln.category;
                }
            });

            // Remove duplicate references
            allReferences = [...new Set(allReferences)];

            // Create the merged vulnerability
            const mergedVulnerability = new Vulnerability({
                cvssv3: highestCvssv3,
                cvssv4: highestCvssv4,
                priority: highestPriority,
                remediationComplexity: highestRemediationComplexity,
                category: category,
                status: 1, // New/created status
                details: [{
                    locale: locale,
                    title: title,
                    vulnType: '',
                    description: mergedDescription.trim(),
                    observation: mergedObservation.trim(),
                    remediation: mergedRemediation.trim(),
                    references: allReferences,
                    customFields: []
                }]
            });

            // Save the merged vulnerability
            await mergedVulnerability.save();

            // Delete source vulnerabilities
            await Vulnerability.deleteMany({ _id: { $in: vulnIds } });

            resolve({
                message: 'Vulnerabilities merged successfully',
                merged: vulnerabilities.length,
                newVulnerabilityId: mergedVulnerability._id
            });
        } catch (err) {
            reject(err);
        }
    });
}

VulnerabilitySchema.statics.getVulnsImages = (vulnsIds = []) => {
    return new Promise((resolve, reject) => {
        var imgRegex = new RegExp(/img src=["']([0-9a-f]{24})["']/)
        var matchFilter = {
            $or: [
                {"details.description": {$regex: imgRegex}},
                {"details.observation": {$regex: imgRegex}},
                {"details.remediation": {$regex: imgRegex}},
                {"details.customFields.text": {$regex: imgRegex}}
            ]
        }
        if (vulnsIds.length > 0)
            matchFilter['_id'] = {$in: vulnsIds.map(e => new mongoose.Types.ObjectId(e))}
        var query = Vulnerability.aggregate([{$match: matchFilter}])
        query.unwind('$details')
        query.unwind({path: '$details.customFields', preserveNullAndEmptyArrays: true})
        query.addFields({
            imageFields: {
            $concat: [
                {$cond: [{$eq: [{$type: "$details.description"}, "string"]}, "$details.description", ""]},
                {$cond: [{$eq: [{$type: "$details.observation"}, "string"]}, "$details.observation", ""]},
                {$cond: [{$eq: [{$type: "$details.remediation"}, "string"]}, "$details.remediation", ""]},
                {$cond: [{$eq: [{$type: "$details.customFields.text"}, "string"]}, "$details.customFields.text", ""]},
            ],
            },
        })
        query.project({
            _id: 0,
            name: "$name",
            images: {
                $regexFindAll: {
                    input: "$imageFields",
                    regex: imgRegex,
                },
            },
        })
        query.exec()
        .then(row => {
            if (!row)
                throw ({ fn: 'NotFound', message: 'Vulnerabilities not found' })
            else {
                var images = []
                row.forEach(e => e.images.forEach(img => images.push(img.captures[0])))
                var imagesUniq = [...new Set(images)]
                resolve(imagesUniq);
            }
        })
        .catch((err) => {
            reject(err)
        })
    })
}

VulnerabilitySchema.statics.backup = (path, vulnsIds = []) => {
    return new Promise(async (resolve, reject) => {
        const fs = require('fs')

        function exportVulnsPromise() { 
            return new Promise((resolve, reject) => {
                let filters = {}

                const writeStream = fs.createWriteStream(`${path}/vulnerabilities.json`)

                writeStream.write('[')

                if (vulnsIds.length > 0)
                    filters = {'_id': {$in: vulnsIds}}
                let vulns = Vulnerability.find(filters).cursor()
                let isFirst = true

                vulns.eachAsync(async (document) => {
                    if (!isFirst) {
                        writeStream.write(',')
                    } else {
                        isFirst = false
                    }
                    writeStream.write(JSON.stringify(document, null, 2))
                    return Promise.resolve()
                })
                .then(() => {
                    writeStream.write(']');
                    writeStream.end();
                })
                .catch((error) => {
                    reject(error);
                });

                writeStream.on('finish', () => {
                    resolve('ok');
                });
            
                writeStream.on('error', (error) => {
                    reject(error);
                });
            })
        }

        function exportImagesPromise() { 
            return new Promise(async (resolve, reject) => {
                const Image = mongoose.model("Image");
                const writeStream = fs.createWriteStream(`${path}/vulnerabilities-images.json`)
                writeStream.write('[')

                let vulnsImages = await Vulnerability.getVulnsImages(vulnsIds)
                let images = Image.find({'_id': {'$in': vulnsImages}}).cursor()

                let isFirst = true
                images.eachAsync(async (document) => {
                    if (!isFirst) {
                        writeStream.write(',')
                    } else {
                        isFirst = false
                    }
                    writeStream.write(JSON.stringify(document, null, 2))
                    return Promise.resolve()
                })
                .then(() => {
                    writeStream.write(']');
                    writeStream.end();
                })
                .catch((error) => {
                    reject(error);
                });

                writeStream.on('finish', () => {
                    resolve('ok');
                });
            
                writeStream.on('error', (error) => {
                    reject(error);
                });
            })
        }

        try {
            await Promise.all([exportVulnsPromise(), exportImagesPromise()])
            resolve()
        }
        catch (error) {
            reject({error: error, model: 'Vulnerability'})
        }
    })
}

VulnerabilitySchema.statics.restore = (path, mode = "upsert") => {
    return new Promise(async (resolve, reject) => {
        const fs = require('fs')

        function importVulnsPromise() {
            let documents = []

            return new Promise((resolve, reject) => {
                const readStream = fs.createReadStream(`${path}/vulnerabilities.json`)
                const JSONStream = require('JSONStream')

                let jsonStream = JSONStream.parse('*')
                readStream.pipe(jsonStream)

                readStream.on('error', (error) => {
                    reject(error)
                })

                jsonStream.on('data', (document) => {
                    documents.push(document)
                    if (documents.length === 100) {
                        Vulnerability.bulkWrite(documents.map(document => {
                            return {
                                replaceOne: {
                                    filter: {details: document.details},
                                    replacement: document,
                                    upsert: true
                                }
                            }
                        }))
                        .catch(err => {
                            reject(err)
                        })
                        documents = []
                    }
                })
                jsonStream.on('end', () => {
                    if (documents.length > 0) {
                        Vulnerability.bulkWrite(documents.map(document => {
                            return {
                                replaceOne: {
                                    filter: {details: document.details},
                                    replacement: document,
                                    upsert: true
                                }
                            }
                        }))
                        .then(() => {
                            resolve()
                        })
                        .catch(err => {
                            reject(err)
                        })
                    }
                    else
                        resolve()
                })
                jsonStream.on('error', (error) => {
                    reject(error)
                })
            })
        }

        function importImagesPromise() {
            let documents = []

            return new Promise((resolve, reject) => {
                const Image = mongoose.model("Image");
                const readStream = fs.createReadStream(`${path}/vulnerabilities-images.json`)
                const JSONStream = require('JSONStream')

                let jsonStream = JSONStream.parse('*')
                readStream.pipe(jsonStream)

                readStream.on('error', (error) => {
                    reject(error)
                })

                jsonStream.on('data', (document) => {
                    documents.push(document)
                    if (documents.length === 100) {
                        Image.bulkWrite(documents.map(document => {
                            return {
                                replaceOne: {
                                    filter: {_id: document._id},
                                    replacement: document,
                                    upsert: true
                                }
                            }
                        }))
                        .catch(err => {
                            reject(err)
                        })
                        documents = []
                    }
                })
                jsonStream.on('end', () => {
                    if (documents.length > 0) {
                        Image.bulkWrite(documents.map(document => {
                            return {
                                replaceOne: {
                                    filter: {_id: document._id},
                                    replacement: document,
                                    upsert: true
                                }
                            }
                        }))
                        .then(() => {
                            resolve()
                        })
                        .catch(err => {
                            reject(err)
                        })
                    }
                    else
                        resolve()
                })
                jsonStream.on('error', (error) => {
                    reject(error)
                })
            })
        }

        try {
            if (mode == "revert")
                await Vulnerability.deleteMany()
            await Promise.all([importVulnsPromise(), importImagesPromise()])
            resolve()
        }
        catch (error) {
            reject({error: error, model: 'Vulnerability'})
        }
    })
}

/*
*** Methods ***
*/

var Vulnerability = mongoose.model('Vulnerability', VulnerabilitySchema);
module.exports = Vulnerability;